{% load static %}
{% if gallery_section.items or gallery_section.rows %}
{% with extra_classes=gallery_section.section_classes|default:"" %}
<section id="gallery" class="explore{% if extra_classes %} {{ extra_classes }}{% endif %}" aria-labelledby="explore-title">
  <div class="wrap">
    <span class="eyebrow">Gallery</span>
    <h2 id="explore-title">{{ gallery_section.title }}</h2>

    <div class="ways-grid">

      <div class="gallery-card-shell span-2">
        <article class="way-card" data-gallery-card data-gallery-primary>
          <img class="switch-img is-active" data-front alt="" />
          <img class="switch-img" data-back alt="" />
          <h3 class="way-title" data-gallery-title></h3>
          <p class="way-desc" data-gallery-desc></p>
        </article>
      </div>

      <article class="way-card" data-gallery-card>
        <img class="switch-img is-active" data-front alt="" />
        <img class="switch-img" data-back alt="" />
        <h3 class="way-title" data-gallery-title></h3>
        <p class="way-desc" data-gallery-desc></p>
      </article>

      <article class="way-card" data-gallery-card>
        <img class="switch-img is-active" data-front alt="" />
        <img class="switch-img" data-back alt="" />
        <h3 class="way-title" data-gallery-title></h3>
        <p class="way-desc" data-gallery-desc></p>
      </article>

      <article class="way-card" data-gallery-card>
        <img class="switch-img is-active" data-front alt="" />
        <img class="switch-img" data-back alt="" />
        <h3 class="way-title" data-gallery-title></h3>
        <p class="way-desc" data-gallery-desc></p>
      </article>

<!-- was: <aside class="way-card gallery-cta" aria-label="Gallery CTA"> -->
  <aside class="gallery-cta" aria-label="Gallery CTA">
    <div class="gallery-cta-inner">
      <span class="cta-eyebrow">Gallery</span>
      <h3 class="cta-title">Explore the beauty of Egypt</h3>
      <p class="cta-desc">From timeless temples to silent seas of sand — see our favourite moments.</p>
    </div>
  </aside>

    </div>

    <div class="gallery-arrows" data-gallery-arrows>

      <button class="gallery-arrow" type="button" aria-label="Previous" data-gallery-prev>&lsaquo;</button>

      <button class="gallery-arrow" type="button" aria-label="Next" data-gallery-next>&rsaquo;</button>

    </div>
  </div>

  {# Hidden data source (no visuals, fed to JS). We prefer rows; fallback to items. #}
  <template id="gallery-data">
    {% if gallery_section.rows %}
      {% for row in gallery_section.rows %}
        {% for item in row %}
          <span data-src="{{ item.image_url }}"
                data-alt="{{ item.alt }}"
                data-title="{{ item.title|default:item.destination }}"
                data-caption="{{ item.caption|default:item.destination }}"></span>
        {% endfor %}
      {% endfor %}
    {% else %}
      {% for item in gallery_section.items %}
        {% if item.image_url %}
          <span data-src="{{ item.image_url }}"
                data-alt="{{ item.alt }}"
                data-title="{{ item.title|default:item.destination }}"
                data-caption="{{ item.caption|default:item.destination }}"></span>
        {% endif %}
      {% endfor %}
    {% endif %}
  </template>
</section>
{% endwith %}
{% endif %}

{% block script %}
<script>
(() => {
  const section = document.getElementById('gallery');
  if (!section) return;

  const tpl = document.getElementById('gallery-data');
  if (!tpl) return;

  // Ensure mobile only shows a single gallery row and expose swipe arrows
  const STYLE_ID = "gallery-mobile-style";
  if (!document.getElementById(STYLE_ID)) {
    const s = document.createElement("style");
    s.id = STYLE_ID;
    s.textContent = `
      #gallery .wrap {
        position: relative;
      }
      #gallery .ways-grid {
        position: relative;
      }
      #gallery [data-gallery-arrows] {
        --arrow-size: 44px;
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        pointer-events: none;
        z-index: 3;
      }
      #gallery [data-gallery-arrows] .gallery-arrow {
        --arrow-size: 44px;
        pointer-events: auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: var(--arrow-size);
        height: var(--arrow-size);
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, .6);
        background: rgba(0, 0, 0, .35);
        color: #fff;
        font-size: 1.75rem;
        line-height: 1;
        transition: background-color .2s ease, border-color .2s ease;
      }
      #gallery [data-gallery-arrows] .gallery-arrow:focus-visible {
        outline: 2px solid rgba(255, 255, 255, .9);
        outline-offset: 3px;
      }
      #gallery [data-gallery-arrows] .gallery-arrow:hover {
        background: rgba(0, 0, 0, .55);
        border-color: rgba(255, 255, 255, .8);
      }
      @media (max-width:899px) {
        #gallery [data-gallery-card]:not([data-gallery-primary]) {
          display: none !important;
        }
        #gallery .gallery-card-shell {
          position: relative;
          overflow: visible;
        }
        #gallery [data-gallery-arrows] {
          display: block;
          padding: 0;
        }
        #gallery [data-gallery-arrows] .gallery-arrow {
          position: absolute;
          top: 50%;
          transform: translateY(-50%);
        }
        #gallery [data-gallery-prev] {
          left: calc(var(--arrow-size) * -0.5);
        }
        #gallery [data-gallery-next] {
          right: calc(var(--arrow-size) * -0.5);
        }
      }

      @media (min-width:900px) {
        #gallery [data-gallery-arrows] {
          left: calc(-1 * ((var(--arrow-size) * 0.5) + clamp(1.5rem, 3vw, 3.5rem)));
          right: calc(-1 * ((var(--arrow-size) * 0.5) + clamp(1.5rem, 3vw, 3.5rem)));
        }
        #gallery [data-gallery-prev],
        #gallery [data-gallery-next] {
          position: static;
          transform: none;
        }
      }
    `;
    document.head.appendChild(s);
  }
  const arrows = section.querySelector('[data-gallery-arrows]');
  const wrap = section.querySelector('.wrap');
  const primaryShell = section.querySelector('.gallery-card-shell');
  const mobileQuery = window.matchMedia('(max-width: 899px)');
  let arrowPlaceholder = null;

  if (arrows && wrap) {
    arrows.style.removeProperty('top');
    arrows.style.removeProperty('transform');
    arrowPlaceholder = document.createElement('span');
    arrowPlaceholder.hidden = true;
    arrowPlaceholder.setAttribute('data-gallery-arrows-slot', 'true');
    wrap.insertBefore(arrowPlaceholder, arrows);
  }

  const syncArrowPlacement = () => {
    if (!arrows) return;

    if (mobileQuery.matches) {
      if (primaryShell && arrows.parentElement !== primaryShell) {
        primaryShell.appendChild(arrows);
      }
    } else if (arrowPlaceholder && arrowPlaceholder.parentNode) {
      const parent = arrowPlaceholder.parentNode;
      if (arrows.parentElement !== parent) {
        parent.insertBefore(arrows, arrowPlaceholder.nextSibling);
      }
    }
  };

  syncArrowPlacement();
  window.addEventListener('resize', syncArrowPlacement, { passive: true });
  window.addEventListener('load', syncArrowPlacement, { once: true });
  if (mobileQuery.addEventListener) {
    mobileQuery.addEventListener('change', syncArrowPlacement);
  } else if (mobileQuery.addListener) {
    mobileQuery.addListener(syncArrowPlacement);
  }

  // Extract images array from template
  const FILE_EXT_PATTERN = /\.(?:jpe?g|png|webp|gif|bmp|avif|heic|heif|tiff?)$/i;
  const sanitizeLabel = (value) => {
    if (!value) return "";
    const trimmed = value.trim();
    if (!trimmed) return "";
    const base = trimmed.split(/[?#]/)[0];
    if (FILE_EXT_PATTERN.test(base)) {
      return "";
    }
    return trimmed;
  };

  const nodes = tpl.content.querySelectorAll('[data-src]');
  const imgs = Array.from(nodes).map(n => {
    const rawTitle = n.dataset.title || "";
    const rawCaption = n.dataset.caption || "";
    const rawAlt = n.dataset.alt || "";
    const title = sanitizeLabel(rawTitle);
    const caption = sanitizeLabel(rawCaption);
    let alt = sanitizeLabel(rawAlt);
    if (!alt) {
      alt = title || caption || "Gallery image";
    }
    return {
      src: n.dataset.src,
      alt,
      title,
      caption
    };
  }).filter(x => !!x.src);

  if (!imgs.length) return;

const cards = Array.from(section.querySelectorAll('[data-gallery-card]'));

  const controllers = [];
  const DURATION_MS = 1200;    // must match CSS transition
  const INTERVAL_MS = 9500;    // time each image is shown
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Space out starting indices so cards don't duplicate the same image at once
  const step = Math.max(1, Math.floor(imgs.length / Math.max(1, cards.length)));

  cards.forEach((card, idx) => {
    const front = card.querySelector('[data-front]');
    const back  = card.querySelector('[data-back]');
    const title = card.querySelector('[data-gallery-title]');
    const desc  = card.querySelector('[data-gallery-desc]');

    let i = (idx * step) % imgs.length;
    let showFront = false; // we'll start by showing "back" for even preload

    const assignActiveMeta = (item, index) => {
      const label = item.title || item.caption || item.alt || "gallery image";
      card.dataset.currentIndex = String(index);
      card.dataset.currentTitle = label;
      card.setAttribute("aria-label", `View ${label}`);
    };

    function setContent(el, item){
      el.src = item.src;
      el.alt = item.alt;
      title.textContent = item.title || item.caption || '';
      desc.textContent  = item.caption || '';
    }

    // Initial content
    setContent(front, imgs[i]);
    i = (i + 1) % imgs.length;
    const initialItem = imgs[i];
    setContent(back, initialItem);
    assignActiveMeta(initialItem, i);

    // Make "back" visible first so both are preloaded
    back.classList.add('is-active');

    card.setAttribute('tabindex', '0');
    card.setAttribute('role', 'button');
    card.classList.add('gallery-card--interactive');

    const activate = (event) => {
      if (event.type === 'keydown' && event.key !== 'Enter' && event.key !== ' ') {
        return;
      }
      event.preventDefault();
      const rawIndex = Number(card.dataset.currentIndex || '0');
      const safeIndex = Number.isFinite(rawIndex) ? rawIndex : 0;
      openLightbox(safeIndex);
    };
    card.addEventListener('click', activate);
    card.addEventListener('keydown', activate);

    const tick = () => {
      i = (i + 1) % imgs.length;

      const entering = showFront ? front : back;
      const exiting  = showFront ? back  : front;
      const nextItem = imgs[i];

      // Prepare next image on the hidden layer
      setContent(entering, nextItem);
      assignActiveMeta(nextItem, i);

      // Trigger swipe: exiting slides left, entering slides from right
      entering.classList.add('is-active');       // opacity:1, translateX(0)
      exiting.classList.add('is-exit');          // opacity:0, translateX(-8%)
      exiting.classList.remove('is-active');

      // Clean up exit class after transition ends
      const clear = () => exiting.classList.remove('is-exit');
      if (prefersReduced) {
        // minimal animations: shorter cleanup
        setTimeout(clear, Math.min(350, DURATION_MS));
      } else {
        exiting.addEventListener('transitionend', clear, { once: true });
      }

      showFront = !showFront;
    };
        const prev = () => { i = (i - 2 + imgs.length) % imgs.length; tick(); };
        controllers.push({ next: tick, prev });

    // Start loop with a small desync jitter so all cards aren’t in lockstep
    const jitter = Math.random() * 800;
    setTimeout(() => {
      tick();
      setInterval(tick, INTERVAL_MS + Math.random() * 900);
    }, jitter);
  });
    const prevBtn = section.querySelector("[data-gallery-prev]");
    const nextBtn = section.querySelector("[data-gallery-next]");
  const adv = (d) => controllers.forEach(c => d === "prev" ? c.prev() : c.next());
  if (prevBtn) prevBtn.addEventListener("click", () => adv("prev"));
  if (nextBtn) nextBtn.addEventListener("click", () => adv("next"));

  let overlay;
  let overlayDialog;
  let overlayImg;
  let overlayTitle;
  let overlayCaption;
  let overlayPrev;
  let overlayNext;
  let overlaySwipeBound = false;
  let lightboxIndex = 0;

  function ensureLightbox() {
    if (overlay) return;

    overlay = document.createElement('div');
    overlay.id = 'gallery-lightbox';
    overlay.setAttribute('aria-hidden', 'true');
    overlay.innerHTML = `
      <div class="gallery-lightbox__backdrop" data-lightbox-close></div>
      <div class="gallery-lightbox__dialog" data-lightbox-dialog role="dialog" aria-modal="true" aria-label="Expanded gallery image" tabindex="-1">
        <button class="gallery-lightbox__close" type="button" aria-label="Close gallery" data-lightbox-close>&times;</button>
        <button class="gallery-lightbox__nav gallery-lightbox__nav--prev" type="button" aria-label="Previous image" data-lightbox-prev>&lsaquo;</button>
        <button class="gallery-lightbox__nav gallery-lightbox__nav--next" type="button" aria-label="Next image" data-lightbox-next>&rsaquo;</button>
        <div class="gallery-lightbox__media">
          <img data-lightbox-image alt="" />
        </div>
        <div class="gallery-lightbox__meta">
          <h3 class="gallery-lightbox__title" data-lightbox-title></h3>
          <p class="gallery-lightbox__caption" data-lightbox-caption></p>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    overlayDialog = overlay.querySelector('[data-lightbox-dialog]');
    overlayImg = overlay.querySelector('[data-lightbox-image]');
    overlayTitle = overlay.querySelector('[data-lightbox-title]');
    overlayCaption = overlay.querySelector('[data-lightbox-caption]');
    overlayPrev = overlay.querySelector('[data-lightbox-prev]');
    overlayNext = overlay.querySelector('[data-lightbox-next]');

    if (!overlaySwipeBound && overlayDialog) {
      overlaySwipeBound = true;
      if (window.PointerEvent) {
        const active = {
          pointerId: null,
          startX: 0,
          startY: 0,
          tracking: false,
        };
        const reset = () => {
          active.pointerId = null;
          active.startX = 0;
          active.startY = 0;
          active.tracking = false;
        };
        overlayDialog.addEventListener('pointerdown', (event) => {
          if (event.pointerType !== 'touch' && event.pointerType !== 'pen') {
            return;
          }
          active.pointerId = event.pointerId;
          active.startX = event.clientX;
          active.startY = event.clientY;
          active.tracking = true;
        });
        overlayDialog.addEventListener('pointermove', (event) => {
          if (!active.tracking || event.pointerId !== active.pointerId) {
            return;
          }
          const dx = event.clientX - active.startX;
          const dy = event.clientY - active.startY;
          if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 12) {
            event.preventDefault();
          }
        }, { passive: false });
        overlayDialog.addEventListener('pointerup', (event) => {
          if (!active.tracking || event.pointerId !== active.pointerId) {
            return;
          }
          const dx = event.clientX - active.startX;
          const dy = event.clientY - active.startY;
          if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 60) {
            if (dx < 0) {
              offsetLightbox(1);
            } else {
              offsetLightbox(-1);
            }
          }
          reset();
        });
        overlayDialog.addEventListener('pointercancel', reset);
      } else {
        const touch = {
          startX: 0,
          startY: 0,
          tracking: false,
        };
        overlayDialog.addEventListener('touchstart', (event) => {
          if (event.touches.length !== 1) return;
          const t = event.touches[0];
          touch.startX = t.clientX;
          touch.startY = t.clientY;
          touch.tracking = true;
        }, { passive: true });
        overlayDialog.addEventListener('touchmove', (event) => {
          if (!touch.tracking || event.touches.length !== 1) return;
          const t = event.touches[0];
          const dx = t.clientX - touch.startX;
          const dy = t.clientY - touch.startY;
          if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 12) {
            event.preventDefault();
          }
        }, { passive: false });
        overlayDialog.addEventListener('touchend', (event) => {
          if (!touch.tracking) return;
          const t = event.changedTouches[0];
          const dx = t.clientX - touch.startX;
          const dy = t.clientY - touch.startY;
          touch.tracking = false;
          if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 60) {
            if (dx < 0) {
              offsetLightbox(1);
            } else {
              offsetLightbox(-1);
            }
          }
        });
        overlayDialog.addEventListener('touchcancel', () => {
          touch.tracking = false;
        });
      }
    }

    if (overlayDialog) {
      overlayDialog.addEventListener('click', (event) => {
        const target = event.target;
        const isNav = target.closest('.gallery-lightbox__nav');
        const isExplicitClose = target.closest('[data-lightbox-close]');
        const isMedia = target.closest('.gallery-lightbox__media');

        if (isExplicitClose || isNav) {
          event.stopPropagation();
          return;
        }

        if (isMedia) {
          event.stopPropagation();
          closeLightbox();
          return;
        }

        event.stopPropagation();
      });
    }

    overlay.addEventListener('click', (event) => {
      if (event.target === overlay || event.target.dataset.lightboxClose !== undefined) {
        closeLightbox();
      }
    });

    overlay.querySelectorAll('[data-lightbox-close]').forEach(btn => {
      btn.addEventListener('click', closeLightbox);
    });

    if (overlayPrev) {
      overlayPrev.hidden = imgs.length <= 1;
      overlayPrev.addEventListener('click', (event) => {
        event.preventDefault();
        offsetLightbox(-1);
      });
    }
    if (overlayNext) {
      overlayNext.hidden = imgs.length <= 1;
      overlayNext.addEventListener('click', (event) => {
        event.preventDefault();
        offsetLightbox(1);
      });
    }
  }

  function showLightboxItem(index) {
    if (!imgs.length) return;

    const total = imgs.length;
    lightboxIndex = ((index % total) + total) % total;

    ensureLightbox();

    const item = imgs[lightboxIndex];
    overlayImg.src = item.src;
    overlayImg.alt = item.alt || item.title || item.caption || 'Gallery image';

    let titleText = item.title || '';
    let captionText = item.caption || '';

    if (overlayTitle) {
      overlayTitle.textContent = titleText;
      const normalizedTitle = titleText.trim();
      overlayTitle.hidden = !normalizedTitle;
      titleText = normalizedTitle;
    }

    if (overlayCaption) {
      overlayCaption.textContent = captionText;
      const normalizedCaption = captionText.trim();
      const sameAsTitle = normalizedCaption && titleText && normalizedCaption.toLowerCase() === titleText.toLowerCase();
      overlayCaption.hidden = !normalizedCaption || sameAsTitle;
    }
  }

  function offsetLightbox(delta) {
    showLightboxItem(lightboxIndex + delta);
  }

  function openLightbox(index) {
    ensureLightbox();
    showLightboxItem(index);

    overlay.classList.add('is-visible');
    overlay.setAttribute('aria-hidden', 'false');
    document.body.classList.add('is-lightbox-open');

    requestAnimationFrame(() => {
      if (overlayDialog) {
        overlayDialog.focus({ preventScroll: true });
      }
    });
  }

  function closeLightbox() {
    if (!overlay) return;

    overlay.classList.remove('is-visible');
    overlay.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('is-lightbox-open');
  }

  function handleLightboxKeydown(event) {
    if (!overlay || !overlay.classList.contains('is-visible')) return;

    const key = event.key;
    if (key === 'Escape') {
      event.preventDefault();
      closeLightbox();
    } else if (key === 'ArrowRight') {
      event.preventDefault();
      offsetLightbox(1);
    } else if (key === 'ArrowLeft') {
      event.preventDefault();
      offsetLightbox(-1);
    }
  }

  document.addEventListener('keydown', handleLightboxKeydown);
})();
</script>
{% endblock %}
